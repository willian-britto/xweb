
    ❤️ will & LoveLyn ❤️
        - all cuteness reserved

    # --disable-rng --disable-coding  -DCUSTOM_RAND_GENERATE_SEED=my_GenerateSeed -DCUSTOM_RAND_GENERATE_BLOCK=my_rand_generate_block -Dmy_rand_generate_block=min
    ./configure \
     --disable-staticmemory --disable-jobserver --disable-hashdrbg

    NO SERVIDOR, TEM RDSEED
    //HAVE_INTEL_RDSEED

    CFLAGS="-DNO_DEV_URANDOM -DHAVE_INTEL_RDRAND -DUSE_INTEL_SPEEDUP -DNO_SHA -DKEEP_PEER_CERT -DNO_SESSION_CACHE -DNO_WOLFSSL_SERVER -DNO_ERROR_STRINGS -DNO_FILESYSTEM -DNO_MD4 -DNO_MD5" \
        ./configure \
            --prefix=/usr  --disable-base64encode \
            --disable-crypttests --disable-examples \
            --disable-harden --enable-singlethreaded \
            --disable-filesystem --disable-asynccrypt --disable-ocsp \
            --disable-md4 --disable-md5 --disable-sha --disable-sha224 --enable-sha256 --enable-sha512 \
            --disable-sslv3 --disable-tlsv10 --enable-tls13 --enable-sni --enable-alpn \
            --enable-fastmath --enable-intelasm --enable-aesni --enable-intelrand \
            --enable-renegotiation-indication

    # TODO: FIXME: PRECISA DISSO?
    # --enable-psk

    TODO: FIXME: DEIXAR O BUFFER INPUT COMO RAW*2.05+65536, E DEIXAR ESTE ENCRYPTED NO FINAL
        SEMPRE QUE POSSÍVEL, MOVê-LO, RETORNÁ-LO, A RAW+RAW_SIZE

    OS DEMAIS PROTOCOLOS SIMPLESMENTE CONSOMEM DO BUFFER RAW, A CADA ETAPA
    -> SEM NECESSIDADE DE COPY?

    TODO: FIXME: TEM QUE SEMPRE LER TUDO O QUE TIVER RECEBIDO, ANTES DE EFETUAR O CLOSE()
    TODO: FIXME: AO ENVIAR PARA UM COM BUFFER DE SAÍDA JÁ FULL, CLOSE THE CONNECTION, AND RETURN FAILED
    NOTE: USAR NULL DEREFERENCE E DEIXAR QUE DÊ SEGMENTATION FAULT AO INVÉS DE LIDAR COM ERROS
    TODO: TCP dns per proxies - usar contagem de resolved IPs; usar o proxy id, usando um bitmask para contar os certificados
    TODO: A CADA 10 MINUTOS, RECARREGAR TODOS OS HOSTNAMES VIA TCP, A PARTIR DE DIFERENTES PROXIES
    TODO: FIXME: USAR SOMENTE OS IPS VISTOS EM MAIS DE 3 SERVIDORES DNS
    TODO: FIXME: FATAL IF TOO MANY HOSTS
    TODO: FIXME: SE TIVER MAIS DO QUE (PROXIES_N - PROXIES_QUEUE_N) PROXIES COM PONTUAÇÃO NO MÁXIMO, RESETAR TODAS PARA (pontuacao -= 5)
                OU SEJA, SE APÓS O SORT, proxies[PROXIES_QUEUE_N-1] >= POINTS_MAX
    TODO: FIXME: SER CAPAZ DE LIMITAR O NUMERO DE CONEXÕES DENTRO DE UM SERVICE
            -> CRINDO ELE COM UM DEFAULT
    TODO: FIXME: SER CAPAZ DE LIMITAR O NUMERO DE CONEXÕES DENTRO DE UM HOST
            -> CRINDO ELE COM UM DEFAULT
    TODO: SER CAPAZ DE LIMITAR O NUMERO DE CONEXÕES DENTRO DE UM HOST:PORT (GLOBAL)
    TODO: SE TIVER ALCANCADO O LIMITE DE CONEXOES, IR RETORNANDO NULL ATÉ CONSEGUIR CRIAR, OU REUTILIZAR UMA
    TODO: LIMITAR A QUANTIDADE DE SERVICOS POR SESSION/GLOBAL?
    TODO: FIXME: SE O ERRRO DA REQUEST É PQ A CONEXÃO FECHOU, ENTÃO NEM SEQUER TENTOU; TEM QUE DAR UM RETRY
    TODO: TEM QUE RESPEITAR O SESSIONCHANGED() NO CONNECT(), OU ACABARÁ CONECTANDO ATOA; NÃO PRECISA, BASTA MOVER A CONEXÃO PARA O NOVO SERVICES
            SE A CONEXÃO AINDA NÃO FEZ NENHUMA REQUEST/STREAM, ENTÃO ELA PODE SER COLOCADA NO NOVO POOL DA NOVA SESSÃO
    TODO: FIXME: vai ter que puxar a conexão da lista IDLE com frequencia, fazer o teste, e colocar ela de novo
            fazer isso após o epoll() e antes de retornar ao Python,
                para que conexẽos que estiveram paradas não sejam reutilizadas antes de testar

    TEM QUE USAR O POOL DA THREAD E NÃO DA SESSÃO
        A THREAD APONTA PARA O USER-AGENT/POOL/COOKIES DA SESSÃO

    -> VAI TER QUE SUPORTAR CRIAR/DELETAR POOLS :S

    ALERTAR PARA AS COISAS QUE FIZEREM REQUESTS/STREAMS E/OU SE MANTEREM COM O USER-AGENT/POOL/COOKIES DA SESSÃO != DO PARENT

    A CONEXÃO É RAW SE NAO VIER NADA NO ALPN, ATÉ QUE SEJA USADA COMO SOCKET, HTTP REQUEST, OU WEBSOCKET
        SE HTTP 1.1 REQUEST, MANTÉM ELA COMO TAL ATÉ QUE SEJA PEDIDO UM WEBSOCKET

    TODO: BIND ADDRESSES RUINS PODEM CAUSAR BAD PROXIES

    A IDÉIA É TER 2*CONNECTIONS_N + 2*DNS_REQUESTS_N DE TAMANHO NO SQE
    - AS CONEXÕES VÃO USAR readv/writev
        NÃO ENVIA NADA ENQUANTOO ULTIMO WRITEV() NAO RETORNAR
        DAI ATUALIZA O QUE AINDA FALTA, E MANDA UM NOVO WRITEV() COM TUDO

    TODO: FIXME: SÓ RESOVLER HOSTNAMES QUE FORAM USADOS E/OU ESTIVERAM CONECTADOS NAS ÚLTIMAS 2 HORAS
        É MELHOR MANTER UMA LISTA E IR PUXANDO PRA FRENTE CONFORME FOREM SENDO USADOS
        MAS SÓ SOBRESCREVE OS QUE ESTIVEREM COM REF 0
    -> FAZER O MESMO COM OS PROXIES

    TODO: FIXME: AQUELE MODELO EM QUE SUBMETE A REQUEST AO POOL, MANTEM UM MINIM DE CONEXOES, ETC

    QUANDO xweb.connect() for True
        conn->retry = 0;
